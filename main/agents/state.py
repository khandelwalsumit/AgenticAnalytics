"""Shared state definitions for the analytics graph."""

from __future__ import annotations

from typing import Annotated, Any, TypedDict

from langchain_core.messages import AnyMessage
from langgraph.graph.message import add_messages


class ExecutionTrace(TypedDict):
    """Structured trace for each agent execution step."""

    step_id: str
    agent: str
    input_summary: str
    output_summary: str
    tools_used: list[str]
    latency_ms: int
    success: bool


class ScopeSnapshot(TypedDict):
    """Strict scope definition for Q&A validation, audit, and report headers."""

    dataset_path: str
    filters: dict[str, Any]
    skills_used: list[str]
    buckets_created: list[str]
    focus_column: str


class RankedFinding(TypedDict):
    """Structured, scored finding from Business Analyst."""

    finding: str
    category: str
    volume: float
    impact_score: float
    ease_score: float
    confidence: float
    recommended_action: str


class ScopeDecision(TypedDict):
    """Output of the Scope Detector classification node."""

    in_scope: bool
    reason: str


class PlanStep(TypedDict):
    """A single step generated by the Supervisor."""

    step_number: int
    next_agent: str
    task_description: str
    requires_user_input: bool
    reasoning: str


class PlanTask(TypedDict):
    """A visible task in the live task list.

    Status values: ``ready`` | ``running`` | ``done`` | ``failed``
    """

    title: str
    agent: str  # node that will execute this task
    status: str  # ready | running | done | failed


class AnalyticsState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]

    # User intent
    user_focus: str
    analysis_type: str  # "domain" | "operational" | "combined"
    selected_skills: list[str]
    critique_enabled: bool

    # Plan (Supervisor generates + executes)
    current_plan: dict[str, Any]
    plan_steps_total: int
    plan_steps_completed: int
    plan_tasks: list[PlanTask]  # Live task list shown in Chainlit UI

    # Execution trace
    execution_trace: list[ExecutionTrace]

    # Data — METADATA ONLY (raw data lives in DataStore)
    dataset_path: str
    dataset_schema: dict[str, Any]
    active_filters: dict[str, Any]
    data_buckets: dict[str, dict[str, Any]]

    # Analysis — scored findings
    findings: list[RankedFinding]
    domain_analysis: dict[str, Any]
    operational_analysis: dict[str, Any]

    # Friction lens agent outputs (written by each agent independently)
    digital_analysis: dict[str, Any]
    operations_analysis: dict[str, Any]
    communication_analysis: dict[str, Any]
    policy_analysis: dict[str, Any]

    # Synthesis output (written by Synthesizer Agent)
    synthesis_result: dict[str, Any]

    # Reporting subgraph outputs
    narrative_output: dict[str, Any]
    dataviz_output: dict[str, Any]
    formatting_output: dict[str, Any]

    # Report — metadata only (full text in DataStore)
    report_markdown_key: str
    report_file_path: str
    data_file_path: str

    # Quality
    critique_feedback: dict[str, Any]
    quality_score: float

    # Control flow
    next_agent: str
    requires_user_input: bool
    checkpoint_message: str
    phase: str  # "analysis" | "qa"

    # Q&A mode
    analysis_complete: bool
    analysis_scope: ScopeSnapshot

    # UI state
    agent_reasoning: list[dict[str, Any]]
