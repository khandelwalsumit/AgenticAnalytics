"""Report tools for the Report Analyst agent."""

from __future__ import annotations

import json
import re
from pathlib import Path

from langchain_core.tools import tool

from core.data_store import DataStore
from utils.pptx_export import generate_pptx_from_slides, markdown_to_pptx

_data_store: DataStore | None = None


def set_data_store(store: DataStore) -> None:
    global _data_store
    _data_store = store


def _get_store() -> DataStore:
    if _data_store is None:
        raise RuntimeError("DataStore not initialized.")
    return _data_store


def _safe_thread_id(raw: str) -> str:
    text = str(raw or "").strip() or "unknown_thread"
    return re.sub(r"[^a-zA-Z0-9_-]", "_", text)[:80]


def _get_thread_id(store: DataStore) -> str:
    """Resolve thread_id from Chainlit session when available."""
    try:
        import chainlit as cl
        thread_id = cl.user_session.get("thread_id")
        if thread_id:
            return _safe_thread_id(str(thread_id))
    except Exception:
        pass
    return _safe_thread_id(store.session_id)


def _get_artifact_dirs(store: DataStore) -> tuple[Path, Path, str]:
    from config import DATA_OUTPUT_DIR, DATA_CACHE_DIR

    thread_id = _get_thread_id(store)
    tmp_dir = Path(DATA_CACHE_DIR) / thread_id
    out_dir = Path(DATA_OUTPUT_DIR) / thread_id
    tmp_dir.mkdir(parents=True, exist_ok=True)
    out_dir.mkdir(parents=True, exist_ok=True)
    return tmp_dir, out_dir, thread_id


@tool
def generate_markdown_report(
    title: str,
    executive_summary: str,
    detailed_findings: str,
    impact_ease_matrix: str,
    recommendations: str,
    data_appendix: str,
) -> str:
    """Generate a structured markdown report from provided sections.

    Sections are rendered in the Narrative Agent's canonical order:
    Executive Summary → Impact vs Ease → Recommendations → Theme Deep Dives → Appendix.

    Args:
        title: Report title.
        executive_summary: Top findings, key metrics, top 3 issues, quick wins.
        detailed_findings: Theme deep-dive sections (one per theme with driver tables).
        impact_ease_matrix: Prioritization table sorted by priority score.
        recommendations: Actions grouped by dimension (digital, ops, comms, policy).
        data_appendix: Bottom-up analysis pipeline trace for debugging
                       (Narrative → Synthesizer → Bucket Agent outputs).

    Returns:
        JSON with the DataStore key for the stored report.
    """
    store = _get_store()
    _tmp_dir, out_dir, _thread_id = _get_artifact_dirs(store)

    # Section order matches Narrative Agent's 4-section structure:
    # 1. Executive Summary → 2. Impact vs Ease → 3. Recommendations → 4. Theme Deep Dives
    # Appendix is bottom-up trace for debugging (Narrative → Synthesizer → Bucket agents)
    report = f"""# {title}

{executive_summary}

---

{impact_ease_matrix}

---

{recommendations}

---

{detailed_findings}

---

{data_appendix}

---
*Report generated by AgenticAnalytics*
"""

    key = store.store_text(
        "report_markdown",
        report,
        metadata={"title": title, "sections": 5},
    )

    # Save markdown in the per-thread final output folder.
    md_path = out_dir / "complete_analysis.md"
    md_path.write_text(report, encoding="utf-8")

    return json.dumps({
        "report_key": key,
        "char_count": len(report),
        "markdown_path": str(md_path),
    })


@tool
def export_to_pptx(
    slide_plan_json: str = "",
    chart_paths_json: str = "",
    report_key: str = "report_markdown",
    output_dir: str = "",
) -> str:
    """Export analysis to PowerPoint using a structured slide plan or markdown fallback.

    Preferred mode: pass ``slide_plan_json`` (from the Narrative Agent) and
    ``chart_paths_json`` (from the DataViz Agent) to generate a template-based
    PPTX with per-slide control.

    Fallback mode: if ``slide_plan_json`` is empty, converts the markdown report
    stored under ``report_key`` into a simple PPTX.

    Args:
        slide_plan_json: JSON string of the Narrative Agent's slide plan.
                         Must contain a ``slides`` list. If empty, uses markdown fallback.
        chart_paths_json: JSON string mapping visual_id → chart image file path.
                          Example: ``{"friction_distribution": "data/friction_distribution.png"}``
        report_key: DataStore key for the markdown report (used in fallback mode).
        output_dir: Directory to save the .pptx file. Uses default data dir if empty.

    Returns:
        JSON with the path to the generated .pptx file.
    """
    store = _get_store()
    _tmp_dir, default_out_dir, _thread_id = _get_artifact_dirs(store)

    from config import PPTX_TEMPLATE_PATH
    out_dir = Path(output_dir) if output_dir else default_out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    output_path = out_dir / "report.pptx"

    if slide_plan_json:
        # Template-based mode — structured slide plan from Narrative Agent
        try:
            slide_plan = json.loads(slide_plan_json)
        except json.JSONDecodeError as e:
            return json.dumps({"error": f"Invalid slide_plan_json: {e}"})

        chart_paths: dict[str, str] = {}
        if chart_paths_json:
            try:
                chart_paths = json.loads(chart_paths_json)
            except json.JSONDecodeError:
                chart_paths = {}

        template_path = PPTX_TEMPLATE_PATH if Path(PPTX_TEMPLATE_PATH).exists() else ""
        generate_pptx_from_slides(slide_plan, chart_paths, str(output_path), template_path)
    else:
        # Legacy fallback — convert markdown report to PPTX
        try:
            markdown_content = store.get_text(report_key)
        except KeyError:
            return json.dumps({"error": f"Report '{report_key}' not found. Generate a markdown report first."})
        markdown_to_pptx(markdown_content, str(output_path))

    return json.dumps({"pptx_path": str(output_path)})


@tool
def export_filtered_csv(output_dir: str = "") -> str:
    """Export the filtered dataset as a downloadable CSV file.

    Args:
        output_dir: Directory to save the CSV file. Uses default data dir if empty.

    Returns:
        JSON with the path to the exported CSV.
    """
    store = _get_store()
    _tmp_dir, default_out_dir, _thread_id = _get_artifact_dirs(store)

    # filter_data is always present — written by filter_data before this runs.
    source = "filter_data"
    df = store.get_dataframe(source)

    out_dir = Path(output_dir) if output_dir else default_out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    output_path = out_dir / "filtered_data.csv"

    df.to_csv(output_path, index=False)

    return json.dumps({
        "csv_path": str(output_path),
        "source": source,
        "row_count": len(df),
        "column_count": len(df.columns),
    })


REPORT_TOOLS = [generate_markdown_report, export_to_pptx, export_filtered_csv]
